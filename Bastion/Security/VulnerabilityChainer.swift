//
//  VulnerabilityChainer.swift
//  Bastion
//
//  Identifies multi-step vulnerability chains that lead to full compromise
//  Combines CVEs into exploitable attack paths
//  Author: Jordan Koch
//  Date: 2026-01-20
//

import Foundation

@MainActor
class VulnerabilityChainer: ObservableObject {
    @Published var chains: [VulnerabilityChain] = []
    @Published var isAnalyzing = false

    private let aiBackend = AIBackendManager.shared

    // MARK: - Chain Analysis

    /// Analyze device vulnerabilities and identify exploitation chains
    func analyzeChains(for device: Device, cveDatabase: CVEDatabase) async -> [VulnerabilityChain] {
        isAnalyzing = true
        defer { isAnalyzing = false }

        print("ðŸ”— CHAINING: Analyzing \(device.vulnerabilities.count) vulnerabilities on \(device.ipAddress)...")

        var discoveredChains: [VulnerabilityChain] = []

        // Pattern 1: Information Disclosure â†’ Authentication Bypass â†’ Privilege Escalation
        discoveredChains.append(contentsOf: findInfoToPrivEscChains(device: device))

        // Pattern 2: SQL Injection â†’ File Read â†’ RCE
        discoveredChains.append(contentsOf: findSQLiToRCEChains(device: device))

        // Pattern 3: Directory Traversal â†’ Config Read â†’ Credential Theft
        discoveredChains.append(contentsOf: findTraversalToCredsChains(device: device))

        // Pattern 4: XSS â†’ CSRF â†’ Admin Access
        discoveredChains.append(contentsOf: findXSSToAdminChains(device: device))

        // Pattern 5: Weak Service â†’ Exploit â†’ Persistence
        discoveredChains.append(contentsOf: findExploitToPersistenceChains(device: device))

        // AI-enhanced chain discovery
        if aiBackend.activeBackend != nil && !device.vulnerabilities.isEmpty {
            discoveredChains.append(contentsOf: await discoverAIChains(device: device))
        }

        // Calculate combined probability for each chain
        for i in 0..<discoveredChains.count {
            discoveredChains[i].calculateTotalProbability()
        }

        // Sort by probability and impact
        discoveredChains.sort { $0.totalSuccessProbability > $1.totalSuccessProbability }

        await MainActor.run {
            self.chains = discoveredChains
        }

        print("ðŸ”— Found \(discoveredChains.count) vulnerability chains")
        return discoveredChains
    }

    // MARK: - Chain Pattern Detection

    private func findInfoToPrivEscChains(device: Device) -> [VulnerabilityChain] {
        var chains: [VulnerabilityChain] = []

        // Look for: Info disclosure + Auth bypass + Priv esc
        let infoDisclosure = device.vulnerabilities.filter { vuln in
            vuln.description.lowercased().contains("information disclosure") ||
            vuln.description.lowercased().contains("information leak")
        }

        let privEsc = device.vulnerabilities.filter { vuln in
            vuln.description.lowercased().contains("privilege escalation") ||
            vuln.description.lowercased().contains("gain privileges")
        }

        if !infoDisclosure.isEmpty && !privEsc.isEmpty {
            let chain = VulnerabilityChain(
                device: device,
                steps: [
                    ChainStep(vulnerability: infoDisclosure[0], action: "Leak credentials or configuration", successProbability: 70),
                    ChainStep(vulnerability: privEsc[0], action: "Escalate to root/admin privileges", successProbability: 60)
                ],
                impact: "Full system compromise",
                chainType: .infoToPrivEsc
            )
            chains.append(chain)
        }

        return chains
    }

    private func findSQLiToRCEChains(device: Device) -> [VulnerabilityChain] {
        var chains: [VulnerabilityChain] = []

        // Web service required
        guard device.openPorts.contains(where: { $0.port == 80 || $0.port == 443 }) else {
            return chains
        }

        let sqli = device.vulnerabilities.filter { vuln in
            vuln.description.lowercased().contains("sql injection")
        }

        let fileRead = device.vulnerabilities.filter { vuln in
            vuln.description.lowercased().contains("file read") ||
            vuln.description.lowercased().contains("directory traversal")
        }

        if !sqli.isEmpty {
            let chain = VulnerabilityChain(
                device: device,
                steps: [
                    ChainStep(vulnerability: sqli[0], action: "SQL injection to database access", successProbability: 75),
                    ChainStep(vulnerability: sqli[0], action: "Use xp_cmdshell or LOAD DATA INFILE for RCE", successProbability: 50),
                    ChainStep(vulnerability: sqli[0], action: "Execute reverse shell payload", successProbability: 60)
                ],
                impact: "Remote code execution via database",
                chainType: .sqliToRCE
            )
            chains.append(chain)
        }

        return chains
    }

    private func findTraversalToCredsChains(device: Device) -> [VulnerabilityChain] {
        var chains: [VulnerabilityChain] = []

        let traversal = device.vulnerabilities.filter { vuln in
            vuln.description.lowercased().contains("directory traversal") ||
            vuln.description.lowercased().contains("path traversal")
        }

        if !traversal.isEmpty && device.openPorts.contains(where: { $0.port == 22 }) {
            let chain = VulnerabilityChain(
                device: device,
                steps: [
                    ChainStep(vulnerability: traversal[0], action: "Read /etc/passwd via traversal", successProbability: 70),
                    ChainStep(vulnerability: traversal[0], action: "Read /etc/shadow or SSH keys", successProbability: 50),
                    ChainStep(vulnerability: traversal[0], action: "Crack passwords offline", successProbability: 60),
                    ChainStep(vulnerability: traversal[0], action: "SSH login with stolen credentials", successProbability: 80)
                ],
                impact: "SSH access with legitimate credentials",
                chainType: .traversalToCreds
            )
            chains.append(chain)
        }

        return chains
    }

    private func findXSSToAdminChains(device: Device) -> [VulnerabilityChain] {
        var chains: [VulnerabilityChain] = []

        guard device.openPorts.contains(where: { $0.port == 80 || $0.port == 443 }) else {
            return chains
        }

        let xss = device.vulnerabilities.filter { vuln in
            vuln.description.lowercased().contains("cross-site scripting") ||
            vuln.description.lowercased().contains("xss")
        }

        if !xss.isEmpty {
            let chain = VulnerabilityChain(
                device: device,
                steps: [
                    ChainStep(vulnerability: xss[0], action: "Inject XSS payload into admin session", successProbability: 60),
                    ChainStep(vulnerability: xss[0], action: "Steal admin session cookie", successProbability: 70),
                    ChainStep(vulnerability: xss[0], action: "Use cookie to access admin panel", successProbability: 80)
                ],
                impact: "Full administrative access to web application",
                chainType: .xssToAdmin
            )
            chains.append(chain)
        }

        return chains
    }

    private func findExploitToPersistenceChains(device: Device) -> [VulnerabilityChain] {
        var chains: [VulnerabilityChain] = []

        // Any RCE vulnerability can lead to persistence
        let rce = device.vulnerabilities.filter { vuln in
            vuln.description.lowercased().contains("remote code execution") ||
            vuln.description.lowercased().contains("command injection") ||
            vuln.description.lowercased().contains("arbitrary code")
        }

        if !rce.isEmpty {
            let chain = VulnerabilityChain(
                device: device,
                steps: [
                    ChainStep(vulnerability: rce[0], action: "Execute remote code", successProbability: 65),
                    ChainStep(vulnerability: rce[0], action: "Create backdoor user account", successProbability: 70),
                    ChainStep(vulnerability: rce[0], action: "Add SSH authorized_keys", successProbability: 80),
                    ChainStep(vulnerability: rce[0], action: "Create cron job for persistence", successProbability: 75)
                ],
                impact: "Persistent access with multiple backdoors",
                chainType: .exploitToPersistence
            )
            chains.append(chain)
        }

        return chains
    }

    // MARK: - AI Chain Discovery

    private func discoverAIChains(device: Device) async -> [VulnerabilityChain] {
        let prompt = """
        Analyze these vulnerabilities and identify exploitation chains.

        TARGET: \(device.ipAddress) (\(device.operatingSystem ?? "unknown"))

        VULNERABILITIES (\(device.vulnerabilities.count)):
        \(device.vulnerabilities.prefix(10).map { "â€¢ \($0.title) - \($0.severity.rawValue)" }.joined(separator: "\n"))

        Identify multi-step attack chains:
        1. What vulnerabilities can be chained together?
        2. What's the exploitation sequence?
        3. What's the final impact?
        4. Success probability for each step?

        Focus on realistic, practical attack chains.
        """

        do {
            let response = try await aiBackend.generate(
                prompt: prompt,
                systemPrompt: "You are an expert at vulnerability chaining and multi-step exploitation. Identify realistic attack chains.",
                temperature: 0.5,
                maxTokens: 600
            )

            // Parse AI response into chains
            // For now, create generic AI-identified chain
            if !device.vulnerabilities.isEmpty {
                let chain = VulnerabilityChain(
                    device: device,
                    steps: device.vulnerabilities.prefix(3).map { vuln in
                        ChainStep(vulnerability: vuln, action: "AI-recommended step", successProbability: 60)
                    },
                    impact: "AI-identified attack chain",
                    chainType: .aiDiscovered
                )
                return [chain]
            }
        } catch {
            print("âŒ AI chain discovery failed: \(error)")
        }

        return []
    }

    // MARK: - Export

    /// Export chains as attack script
    func exportAsScript(chains: [VulnerabilityChain]) -> String {
        var script = "#!/bin/bash\n"
        script += "# Bastion - Generated Exploitation Chain Script\n"
        script += "# Date: \(Date().formatted(date: .abbreviated, time: .standard))\n"
        script += "# WARNING: For authorized testing only\n\n"

        for (index, chain) in chains.prefix(5).enumerated() {
            script += "# Chain \(index + 1): \(chain.description)\n"
            script += "# Target: \(chain.device.ipAddress)\n"
            script += "# Success Probability: \(chain.totalSuccessProbability)%\n\n"

            for (stepIndex, step) in chain.steps.enumerated() {
                script += "# Step \(stepIndex + 1): \(step.action)\n"
                script += "echo 'Executing step \(stepIndex + 1)...'\n"
                script += "# [Insert exploit command here]\n\n"
            }

            script += "echo 'Chain \(index + 1) complete'\n"
            script += "echo '---'\n\n"
        }

        return script
    }
}

// MARK: - Data Models

struct VulnerabilityChain: Identifiable {
    let id = UUID()
    let device: Device
    var steps: [ChainStep]
    let impact: String
    let chainType: ChainType
    var totalSuccessProbability: Double = 0

    mutating func calculateTotalProbability() {
        // Combined probability = product of individual probabilities
        var combined: Double = 1.0
        for step in steps {
            combined *= (Double(step.successProbability) / 100.0)
        }
        totalSuccessProbability = combined * 100
    }

    var description: String {
        "\(steps.count)-step chain: \(chainType.rawValue) â†’ \(impact)"
    }
}

struct ChainStep: Identifiable {
    let id = UUID()
    let vulnerability: Vulnerability
    let action: String
    let successProbability: Int // 0-100
}

enum ChainType: String, CaseIterable {
    case infoToPrivEsc = "Info Disclosure â†’ Privilege Escalation"
    case sqliToRCE = "SQL Injection â†’ RCE"
    case traversalToCreds = "Path Traversal â†’ Credential Theft"
    case xssToAdmin = "XSS â†’ Admin Takeover"
    case exploitToPersistence = "Initial Exploit â†’ Persistence"
    case aiDiscovered = "AI-Discovered Chain"
    case customChain = "Custom Chain"
}
