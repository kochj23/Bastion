//
//  SMBModule.swift
//  Bastion
//
//  SMB/Samba security testing module
//  Tests for EternalBlue, NULL sessions, anonymous shares, SMB signing
//  Author: Jordan Koch
//  Date: 2026-01-20
//

import Foundation

@MainActor
class SMBModule: ObservableObject {
    @Published var testLog: [String] = []
    @Published var isRunning = false

    // MARK: - EternalBlue (MS17-010) Detection

    /// Test for EternalBlue vulnerability (MS17-010)
    /// One of the most critical Windows exploits ever discovered
    func testEternalBlue(target: String) async -> AttackResult {
        var result = AttackResult(targetIP: target, attackType: .smbExploit, module: "SMB")
        addLog("Testing for EternalBlue (MS17-010) on \(target):445...")

        SafetyValidator.shared.logActivity("EternalBlue test", target: target)

        // Use nmap NSE script for detection
        let nmap = await runCommand(
            "/opt/homebrew/bin/nmap",
            args: ["-p445", "--script", "smb-vuln-ms17-010", target]
        )

        if let output = nmap, output.contains("VULNERABLE") || output.contains("MS17-010") {
            result.status = .success
            result.vulnerabilityConfirmed = true
            result.details = "ðŸš¨ CRITICAL: EternalBlue (MS17-010) vulnerability detected!"
            result.evidence.append("SMB service vulnerable to EternalBlue")
            addLog("âš ï¸ CRITICAL: EternalBlue vulnerability confirmed")
            return result
        }

        result.status = .failed
        result.details = "EternalBlue not detected (patched or not Windows)"
        addLog("âœ“ EternalBlue test complete - not vulnerable")
        return result
    }

    // MARK: - NULL Session Enumeration

    /// Test for NULL session (anonymous SMB access)
    /// Can enumerate users, shares, and policies without credentials
    func testNullSession(target: String) async -> AttackResult {
        var result = AttackResult(targetIP: target, attackType: .smbExploit, module: "SMB")
        addLog("Testing NULL session enumeration on \(target):445...")

        SafetyValidator.shared.logActivity("SMB NULL session test", target: target)

        // Try smbclient with no credentials
        let smbclient = await runCommand(
            "/usr/bin/smbclient",
            args: ["-L", "//\(target)", "-N"]
        )

        if let output = smbclient {
            if output.contains("Sharename") || output.contains("Domain=") {
                result.status = .success
                result.vulnerabilityConfirmed = true
                result.details = "âš ï¸ NULL session allowed - can enumerate shares anonymously"
                result.evidence.append("SMB NULL session successful")
                result.evidence.append(output)
                addLog("âš ï¸ NULL session vulnerability found")
                return result
            }

            if output.contains("NT_STATUS_ACCESS_DENIED") {
                result.status = .failed
                result.details = "âœ“ NULL sessions disabled (good security)"
                addLog("âœ“ NULL sessions properly disabled")
                return result
            }
        }

        result.status = .failed
        result.details = "Unable to test NULL sessions (service may not be SMB)"
        addLog("NULL session test inconclusive")
        return result
    }

    // MARK: - Anonymous Share Enumeration

    /// Enumerate SMB shares and test for anonymous access
    func enumerateShares(target: String) async -> AttackResult {
        var result = AttackResult(targetIP: target, attackType: .smbExploit, module: "SMB")
        addLog("Enumerating SMB shares on \(target):445...")

        SafetyValidator.shared.logActivity("SMB share enumeration", target: target)

        // Use enum4linux for comprehensive enumeration
        let enum4linux = await runCommand(
            "/opt/homebrew/bin/enum4linux",
            args: ["-a", target]
        )

        if let output = enum4linux {
            let shares = extractShares(from: output)
            let users = extractUsers(from: output)

            if !shares.isEmpty || !users.isEmpty {
                result.status = .success
                result.vulnerabilityConfirmed = true
                result.details = "Found \(shares.count) shares and \(users.count) users via anonymous access"
                result.evidence.append("Shares: \(shares.joined(separator: ", "))")
                if !users.isEmpty {
                    result.evidence.append("Users: \(users.joined(separator: ", "))")
                }
                addLog("âš ï¸ Anonymous SMB enumeration successful")
                return result
            }
        }

        // Fallback to smbclient
        let shares = await enumerateSharesWithSmbclient(target: target)
        if !shares.isEmpty {
            result.status = .success
            result.vulnerabilityConfirmed = true
            result.details = "Found \(shares.count) accessible shares"
            result.evidence = shares
            return result
        }

        result.status = .failed
        result.details = "No anonymous access to SMB shares"
        addLog("âœ“ SMB shares properly protected")
        return result
    }

    // MARK: - SMB Signing Verification

    /// Check if SMB signing is enabled (prevents relay attacks)
    func testSMBSigning(target: String) async -> AttackResult {
        var result = AttackResult(targetIP: target, attackType: .smbExploit, module: "SMB")
        addLog("Testing SMB signing configuration on \(target):445...")

        SafetyValidator.shared.logActivity("SMB signing test", target: target)

        let nmap = await runCommand(
            "/opt/homebrew/bin/nmap",
            args: ["-p445", "--script", "smb-security-mode", target]
        )

        if let output = nmap {
            if output.contains("Message signing enabled but not required") ||
               output.contains("signing: disabled") {
                result.status = .success
                result.vulnerabilityConfirmed = true
                result.details = "âš ï¸ SMB signing not required - vulnerable to relay attacks"
                result.evidence.append("SMB signing: optional or disabled")
                addLog("âš ï¸ SMB relay attack possible - signing not enforced")
                return result
            }

            if output.contains("Message signing enabled and required") {
                result.status = .failed
                result.details = "âœ“ SMB signing required (relay attacks prevented)"
                addLog("âœ“ SMB signing properly enforced")
                return result
            }
        }

        result.status = .failed
        result.details = "Unable to determine SMB signing status"
        addLog("SMB signing test inconclusive")
        return result
    }

    // MARK: - SMB Version Detection

    /// Detect SMB version (SMBv1 is insecure and deprecated)
    func detectSMBVersion(target: String) async -> ServiceInfo? {
        addLog("Detecting SMB version on \(target):445...")

        let nmap = await runCommand(
            "/opt/homebrew/bin/nmap",
            args: ["-p445", "--script", "smb-protocols", target]
        )

        guard let output = nmap else {
            return nil
        }

        var service = ServiceInfo(name: "SMB", port: 445)

        // Check for SMBv1 (insecure)
        if output.contains("SMBv1") || output.contains("NT LM 0.12") {
            service.version = "SMBv1 (INSECURE)"
            service.banner = "âš ï¸ SMBv1 enabled - vulnerable to ransomware and exploits"
            addLog("âš ï¸ CRITICAL: SMBv1 detected (WannaCry/NotPetya vulnerability)")
        } else if output.contains("SMB 2.0") || output.contains("SMB 2.1") {
            service.version = "SMBv2"
            service.banner = "SMB 2.x detected"
            addLog("SMBv2 detected")
        } else if output.contains("SMB 3.0") || output.contains("SMB 3.1") {
            service.version = "SMBv3"
            service.banner = "SMB 3.x detected (secure)"
            addLog("âœ“ SMBv3 detected (secure)")
        }

        return service
    }

    // MARK: - Comprehensive SMB Assessment

    /// Run all SMB tests and return comprehensive results
    func runComprehensiveSMBTest(target: String) async -> [AttackResult] {
        isRunning = true
        defer { isRunning = false }

        var results: [AttackResult] = []

        addLog("ðŸ”’ Starting comprehensive SMB assessment on \(target)")

        // Test 1: EternalBlue
        let eternalBlue = await testEternalBlue(target: target)
        results.append(eternalBlue)

        // Test 2: NULL Session
        let nullSession = await testNullSession(target: target)
        results.append(nullSession)

        // Test 3: Share Enumeration
        let shares = await enumerateShares(target: target)
        results.append(shares)

        // Test 4: SMB Signing
        let signing = await testSMBSigning(target: target)
        results.append(signing)

        addLog("âœ… SMB assessment complete - \(results.filter { $0.vulnerabilityConfirmed }.count) vulnerabilities found")

        return results
    }

    // MARK: - Helper Functions

    private func enumerateSharesWithSmbclient(target: String) async -> [String] {
        guard let output = await runCommand("/usr/bin/smbclient", args: ["-L", "//\(target)", "-N"]) else {
            return []
        }

        var shares: [String] = []
        let lines = output.components(separatedBy: "\n")

        for line in lines {
            if line.contains("Disk") || line.contains("IPC") {
                let components = line.split(separator: " ").map(String.init)
                if let shareName = components.first {
                    shares.append(shareName)
                }
            }
        }

        return shares
    }

    private func extractShares(from output: String) -> [String] {
        var shares: [String] = []
        let lines = output.components(separatedBy: "\n")

        for line in lines {
            if line.contains("Sharename:") {
                let parts = line.split(separator: ":").map { $0.trimmingCharacters(in: .whitespaces) }
                if parts.count > 1 {
                    shares.append(parts[1])
                }
            }
        }

        return shares
    }

    private func extractUsers(from output: String) -> [String] {
        var users: [String] = []
        let lines = output.components(separatedBy: "\n")

        var inUserSection = false
        for line in lines {
            if line.contains("Users on") {
                inUserSection = true
                continue
            }

            if inUserSection {
                if line.isEmpty || line.starts(with: "=") {
                    break
                }
                let trimmed = line.trimmingCharacters(in: .whitespaces)
                if !trimmed.isEmpty {
                    users.append(trimmed)
                }
            }
        }

        return users
    }

    private func runCommand(_ path: String, args: [String]) async -> String? {
        return await withCheckedContinuation { continuation in
            let task = Process()
            task.executableURL = URL(fileURLWithPath: path)
            task.arguments = args

            let outputPipe = Pipe()
            let errorPipe = Pipe()
            task.standardOutput = outputPipe
            task.standardError = errorPipe

            do {
                try task.run()

                // Timeout after 10 seconds
                DispatchQueue.global().asyncAfter(deadline: .now() + 10) {
                    if task.isRunning {
                        task.terminate()
                    }
                }

                task.waitUntilExit()

                let outputData = outputPipe.fileHandleForReading.readDataToEndOfFile()
                let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()

                let output = String(data: outputData, encoding: .utf8) ?? ""
                let error = String(data: errorData, encoding: .utf8) ?? ""

                let combined = output + error
                continuation.resume(returning: combined.isEmpty ? nil : combined)
            } catch {
                continuation.resume(returning: nil)
            }
        }
    }

    private func addLog(_ message: String) {
        let timestamp = Date().formatted(date: .omitted, time: .standard)
        let logMessage = "[\(timestamp)] \(message)"
        testLog.append(logMessage)
        print(logMessage)
    }
}

// MARK: - SMB Attack Types

extension AttackType {
    static let smbNullSession = AttackType(rawValue: "SMB NULL Session") ?? .smbExploit
    static let smbEternalBlue = AttackType(rawValue: "EternalBlue") ?? .smbExploit
    static let smbShareEnum = AttackType(rawValue: "SMB Share Enumeration") ?? .smbExploit
    static let smbRelay = AttackType(rawValue: "SMB Relay Attack") ?? .smbExploit
}
