//
//  LDAPModule.swift
//  Bastion
//
//  Active Directory / LDAP security testing module
//  Tests for anonymous bind, user enumeration, kerberoasting
//  Author: Jordan Koch
//  Date: 2026-01-20
//

import Foundation

@MainActor
class LDAPModule: ObservableObject {
    @Published var testLog: [String] = []
    @Published var isRunning = false

    // MARK: - Anonymous LDAP Bind Test

    /// Test if LDAP allows anonymous binds
    /// Can enumerate domain users and groups without credentials
    func testAnonymousBind(target: String, port: Int = 389) async -> AttackResult {
        var result = AttackResult(targetIP: target, attackType: .other, module: "LDAP")
        addLog("Testing anonymous LDAP bind on \(target):\(port)...")

        SafetyValidator.shared.logActivity("LDAP anonymous bind test", target: target)

        // Try ldapsearch with anonymous bind
        let ldapsearch = await runCommand(
            "/usr/bin/ldapsearch",
            args: ["-x", "-h", target, "-p", "\(port)", "-b", "", "-s", "base", "objectClass=*"]
        )

        if let output = ldapsearch {
            if output.contains("namingContexts:") || output.contains("dn:") {
                result.status = .success
                result.vulnerabilityConfirmed = true
                result.details = "âš ï¸ Anonymous LDAP bind allowed - can enumerate directory"
                result.evidence.append("Anonymous bind successful")

                // Extract naming contexts
                let contexts = extractNamingContexts(from: output)
                if !contexts.isEmpty {
                    result.evidence.append("Naming contexts: \(contexts.joined(separator: ", "))")
                }

                addLog("âš ï¸ Anonymous LDAP bind vulnerability confirmed")
                return result
            }

            if output.contains("Invalid credentials") || output.contains("bind failed") {
                result.status = .failed
                result.details = "âœ“ Anonymous bind disabled (good security)"
                addLog("âœ“ LDAP properly requires authentication")
                return result
            }
        }

        result.status = .failed
        result.details = "Unable to test LDAP"
        addLog("LDAP test inconclusive")
        return result
    }

    // MARK: - User Enumeration

    /// Enumerate Active Directory users
    func enumerateUsers(target: String, baseDN: String) async -> [String] {
        addLog("Enumerating AD users from \(target)...")

        let ldapsearch = await runCommand(
            "/usr/bin/ldapsearch",
            args: ["-x", "-h", target, "-b", baseDN, "(objectClass=user)", "sAMAccountName"]
        )

        guard let output = ldapsearch else {
            return []
        }

        var users: [String] = []
        let lines = output.components(separatedBy: "\n")

        for line in lines {
            if line.contains("sAMAccountName:") {
                let parts = line.split(separator: ":").map { $0.trimmingCharacters(in: .whitespaces) }
                if parts.count > 1 {
                    users.append(parts[1])
                }
            }
        }

        addLog("Found \(users.count) users in Active Directory")
        return users
    }

    // MARK: - Group Enumeration

    /// Enumerate Active Directory groups
    func enumerateGroups(target: String, baseDN: String) async -> [String] {
        addLog("Enumerating AD groups from \(target)...")

        let ldapsearch = await runCommand(
            "/usr/bin/ldapsearch",
            args: ["-x", "-h", target, "-b", baseDN, "(objectClass=group)", "cn"]
        )

        guard let output = ldapsearch else {
            return []
        }

        var groups: [String] = []
        let lines = output.components(separatedBy: "\n")

        for line in lines {
            if line.contains("cn:") && !line.contains("dn:") {
                let parts = line.split(separator: ":").map { $0.trimmingCharacters(in: .whitespaces) }
                if parts.count > 1 {
                    groups.append(parts[1])
                }
            }
        }

        addLog("Found \(groups.count) groups in Active Directory")
        return groups
    }

    // MARK: - Kerberoasting Detection

    /// Check for Kerberoasting vulnerability
    /// Identifies service accounts with weak encryption
    func testKerberoasting(target: String) async -> AttackResult {
        var result = AttackResult(targetIP: target, attackType: .other, module: "LDAP/AD")
        addLog("Testing for Kerberoasting vulnerability on \(target)...")

        SafetyValidator.shared.logActivity("Kerberoasting test", target: target)

        // Check for accounts with SPN (servicePrincipalName)
        let ldapsearch = await runCommand(
            "/usr/bin/ldapsearch",
            args: ["-x", "-h", target, "-b", "DC=*", "servicePrincipalName=*", "sAMAccountName", "servicePrincipalName"]
        )

        if let output = ldapsearch, output.contains("servicePrincipalName:") {
            let spns = extractSPNs(from: output)

            result.status = .success
            result.vulnerabilityConfirmed = true
            result.details = "âš ï¸ Kerberoastable accounts found - service account passwords may be crackable"
            result.evidence.append("Found \(spns.count) accounts with SPNs")
            result.evidence.append(contentsOf: spns.prefix(10))
            addLog("âš ï¸ Kerberoasting vulnerability confirmed - \(spns.count) targets")

            return result
        }

        result.status = .failed
        result.details = "No kerberoastable accounts found"
        addLog("Kerberoasting test complete - no vulnerable accounts")
        return result
    }

    // MARK: - Password Policy Enumeration

    /// Enumerate password policy (min length, complexity, lockout)
    func enumeratePasswordPolicy(target: String, baseDN: String) async -> AttackResult {
        var result = AttackResult(targetIP: target, attackType: .other, module: "LDAP/AD")
        addLog("Enumerating password policy from \(target)...")

        let ldapsearch = await runCommand(
            "/usr/bin/ldapsearch",
            args: ["-x", "-h", target, "-b", baseDN, "(objectClass=domainDNS)", "pwdProperties", "minPwdLength", "lockoutThreshold"]
        )

        if let output = ldapsearch {
            var policyDetails: [String] = []

            // Extract password minimum length
            if let minLength = extractAttribute(from: output, attribute: "minPwdLength") {
                policyDetails.append("Minimum password length: \(minLength) chars")

                if let length = Int(minLength), length < 12 {
                    result.vulnerabilityConfirmed = true
                }
            }

            // Extract lockout threshold
            if let lockout = extractAttribute(from: output, attribute: "lockoutThreshold") {
                policyDetails.append("Account lockout threshold: \(lockout) attempts")

                if let attempts = Int(lockout), attempts == 0 {
                    result.vulnerabilityConfirmed = true
                    policyDetails.append("âš ï¸ No account lockout - brute force possible")
                }
            }

            if !policyDetails.isEmpty {
                result.status = result.vulnerabilityConfirmed ? .success : .failed
                result.details = result.vulnerabilityConfirmed ? "âš ï¸ Weak password policy detected" : "âœ“ Strong password policy"
                result.evidence = policyDetails
                addLog(result.vulnerabilityConfirmed ? "âš ï¸ Weak password policy" : "âœ“ Strong password policy")
            } else {
                result.status = .failed
                result.details = "Unable to enumerate password policy"
            }
        }

        return result
    }

    // MARK: - Comprehensive LDAP/AD Assessment

    /// Run all LDAP/AD tests
    func runComprehensiveLDAPTest(target: String, baseDN: String = "DC=local") async -> [AttackResult] {
        isRunning = true
        defer { isRunning = false }

        var results: [AttackResult] = []

        addLog("ðŸ” Starting comprehensive LDAP/AD assessment on \(target)")

        // Test 1: Anonymous Bind
        results.append(await testAnonymousBind(target: target))

        // Test 2: Kerberoasting
        results.append(await testKerberoasting(target: target))

        // Test 3: Password Policy
        results.append(await enumeratePasswordPolicy(target: target, baseDN: baseDN))

        addLog("âœ… LDAP/AD assessment complete - \(results.filter { $0.vulnerabilityConfirmed }.count) vulnerabilities found")

        return results
    }

    // MARK: - Helper Functions

    private func extractNamingContexts(from output: String) -> [String] {
        var contexts: [String] = []
        let lines = output.components(separatedBy: "\n")

        for line in lines {
            if line.contains("namingContexts:") {
                let parts = line.split(separator: ":").map { $0.trimmingCharacters(in: .whitespaces) }
                if parts.count > 1 {
                    contexts.append(parts[1])
                }
            }
        }

        return contexts
    }

    private func extractSPNs(from output: String) -> [String] {
        var spns: [String] = []
        let lines = output.components(separatedBy: "\n")

        for line in lines {
            if line.contains("servicePrincipalName:") {
                let parts = line.split(separator: ":").map { $0.trimmingCharacters(in: .whitespaces) }
                if parts.count > 1 {
                    spns.append(parts[1])
                }
            }
        }

        return spns
    }

    private func extractAttribute(from output: String, attribute: String) -> String? {
        let lines = output.components(separatedBy: "\n")

        for line in lines {
            if line.contains("\(attribute):") {
                let parts = line.split(separator: ":").map { $0.trimmingCharacters(in: .whitespaces) }
                if parts.count > 1 {
                    return parts[1]
                }
            }
        }

        return nil
    }

    private func runCommand(_ path: String, args: [String]) async -> String? {
        return await withCheckedContinuation { continuation in
            let task = Process()
            task.executableURL = URL(fileURLWithPath: path)
            task.arguments = args

            let outputPipe = Pipe()
            let errorPipe = Pipe()
            task.standardOutput = outputPipe
            task.standardError = errorPipe

            do {
                try task.run()

                DispatchQueue.global().asyncAfter(deadline: .now() + 10) {
                    if task.isRunning {
                        task.terminate()
                    }
                }

                task.waitUntilExit()

                let outputData = outputPipe.fileHandleForReading.readDataToEndOfFile()
                let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()

                let output = String(data: outputData, encoding: .utf8) ?? ""
                let error = String(data: errorData, encoding: .utf8) ?? ""

                let combined = output + error
                continuation.resume(returning: combined.isEmpty ? nil : combined)
            } catch {
                continuation.resume(returning: nil)
            }
        }
    }

    private func addLog(_ message: String) {
        let timestamp = Date().formatted(date: .omitted, time: .standard)
        let logMessage = "[\(timestamp)] \(message)"
        testLog.append(logMessage)
        print(logMessage)
    }
}
