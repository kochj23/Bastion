//
//  DNSModule.swift
//  Bastion
//
//  DNS security testing module
//  Tests for zone transfers, amplification, cache poisoning, subdomain enumeration
//  Author: Jordan Koch
//  Date: 2026-01-20
//

import Foundation

@MainActor
class DNSModule: ObservableObject {
    @Published var testLog: [String] = []
    @Published var isRunning = false

    // MARK: - Zone Transfer Test (AXFR)

    /// Test for DNS zone transfer vulnerability
    /// Exposes all internal DNS records if misconfigured
    func testZoneTransfer(target: String, domain: String? = nil) async -> AttackResult {
        var result = AttackResult(targetIP: target, attackType: .other, module: "DNS")
        addLog("Testing DNS zone transfer (AXFR) on \(target):53...")

        SafetyValidator.shared.logActivity("DNS zone transfer test", target: target)

        // Try zone transfer with dig
        let testDomain = domain ?? "local"
        let dig = await runCommand(
            "/usr/bin/dig",
            args: ["@\(target)", testDomain, "AXFR"]
        )

        if let output = dig {
            // Check if zone transfer succeeded
            if output.contains("ANSWER SECTION") && !output.contains("Transfer failed") {
                result.status = .success
                result.vulnerabilityConfirmed = true
                result.details = "âš ï¸ DNS zone transfer allowed - internal network exposed"
                result.evidence.append("Zone transfer successful for domain: \(testDomain)")

                // Extract DNS records
                let records = extractDNSRecords(from: output)
                if !records.isEmpty {
                    result.evidence.append("Discovered \(records.count) DNS records")
                    result.evidence.append(contentsOf: records.prefix(10))
                }

                addLog("âš ï¸ DNS zone transfer vulnerability confirmed")
                return result
            }

            if output.contains("Transfer failed") || output.contains("refused") {
                result.status = .failed
                result.details = "âœ“ Zone transfers disabled (good security)"
                addLog("âœ“ Zone transfers properly restricted")
                return result
            }
        }

        result.status = .failed
        result.details = "Unable to test zone transfers"
        addLog("Zone transfer test inconclusive")
        return result
    }

    // MARK: - DNS Amplification Test

    /// Check if DNS server can be used for amplification attacks
    /// Tests for open recursion
    func testAmplification(target: String) async -> AttackResult {
        var result = AttackResult(targetIP: target, attackType: .other, module: "DNS")
        addLog("Testing DNS amplification vulnerability on \(target):53...")

        SafetyValidator.shared.logActivity("DNS amplification test", target: target)

        // Test open recursion by querying external domain
        let dig = await runCommand(
            "/usr/bin/dig",
            args: ["@\(target)", "google.com", "+short"]
        )

        if let output = dig, !output.isEmpty && output.contains(".") {
            // DNS resolved external query - open recursion
            result.status = .success
            result.vulnerabilityConfirmed = true
            result.details = "âš ï¸ Open DNS recursion detected - can be used for amplification attacks"
            result.evidence.append("DNS server resolved external query: google.com")
            result.evidence.append("Amplification factor: ~50x (DNS response larger than query)")
            addLog("âš ï¸ DNS amplification vulnerability found")
        } else {
            result.status = .failed
            result.details = "âœ“ DNS recursion restricted (good security)"
            addLog("âœ“ DNS server does not allow open recursion")
        }

        return result
    }

    // MARK: - Subdomain Enumeration

    /// Enumerate subdomains via DNS brute force
    func enumerateSubdomains(target: String, domain: String) async -> [String] {
        addLog("Enumerating subdomains for \(domain) via \(target):53...")

        let commonSubdomains = [
            "www", "mail", "ftp", "admin", "api", "dev", "test", "staging",
            "webmail", "smtp", "pop", "imap", "vpn", "remote", "portal",
            "gateway", "router", "ns1", "ns2", "dns", "backup", "db", "sql"
        ]

        var discovered: [String] = []

        for subdomain in commonSubdomains {
            let fullDomain = "\(subdomain).\(domain)"

            if let output = await runCommand("/usr/bin/dig", args: ["@\(target)", fullDomain, "+short"]) {
                if !output.isEmpty && output.contains(".") {
                    discovered.append("\(fullDomain) â†’ \(output.trimmingCharacters(in: .whitespacesAndNewlines))")
                    addLog("  âœ“ Found: \(fullDomain)")
                }
            }

            // Rate limit
            try? await Task.sleep(nanoseconds: 100_000_000) // 0.1s
        }

        addLog("Subdomain enumeration complete - found \(discovered.count) subdomains")
        return discovered
    }

    // MARK: - DNSSEC Validation

    /// Check if DNSSEC is properly configured
    func testDNSSEC(target: String, domain: String) async -> AttackResult {
        var result = AttackResult(targetIP: target, attackType: .other, module: "DNS")
        addLog("Testing DNSSEC configuration for \(domain)...")

        let dig = await runCommand(
            "/usr/bin/dig",
            args: ["@\(target)", domain, "+dnssec"]
        )

        if let output = dig {
            if output.contains("ad;") || output.contains("RRSIG") {
                result.status = .failed // Not vulnerable
                result.details = "âœ“ DNSSEC enabled (good security)"
                addLog("âœ“ DNSSEC validation active")
            } else {
                result.status = .success
                result.vulnerabilityConfirmed = true
                result.details = "âš ï¸ DNSSEC not enabled - vulnerable to DNS spoofing"
                result.evidence.append("No DNSSEC signatures found")
                addLog("âš ï¸ DNSSEC not configured")
            }
        }

        return result
    }

    // MARK: - DNS Cache Snooping

    /// Test if DNS cache snooping is possible
    /// Can reveal browsing history of network users
    func testCacheSnooping(target: String) async -> AttackResult {
        var result = AttackResult(targetIP: target, attackType: .other, module: "DNS")
        addLog("Testing DNS cache snooping on \(target):53...")

        SafetyValidator.shared.logActivity("DNS cache snooping test", target: target)

        // Query for popular domains without recursion
        let popularDomains = ["google.com", "facebook.com", "amazon.com", "apple.com"]
        var cachedDomains: [String] = []

        for domain in popularDomains {
            let dig = await runCommand(
                "/usr/bin/dig",
                args: ["@\(target)", domain, "+norecurse"]
            )

            if let output = dig, output.contains("ANSWER SECTION") {
                cachedDomains.append(domain)
            }

            try? await Task.sleep(nanoseconds: 100_000_000)
        }

        if !cachedDomains.isEmpty {
            result.status = .success
            result.vulnerabilityConfirmed = true
            result.details = "âš ï¸ DNS cache snooping possible - can reveal user activity"
            result.evidence.append("Cached domains revealed: \(cachedDomains.joined(separator: ", "))")
            addLog("âš ï¸ DNS cache snooping vulnerability")
        } else {
            result.status = .failed
            result.details = "âœ“ DNS cache snooping prevented"
            addLog("âœ“ DNS cache properly protected")
        }

        return result
    }

    // MARK: - Comprehensive DNS Assessment

    /// Run all DNS tests
    func runComprehensiveDNSTest(target: String, domain: String = "local") async -> [AttackResult] {
        isRunning = true
        defer { isRunning = false }

        var results: [AttackResult] = []

        addLog("ðŸ” Starting comprehensive DNS assessment on \(target)")

        // Test 1: Zone Transfer
        results.append(await testZoneTransfer(target: target, domain: domain))

        // Test 2: Amplification
        results.append(await testAmplification(target: target))

        // Test 3: DNSSEC
        results.append(await testDNSSEC(target: target, domain: domain))

        // Test 4: Cache Snooping
        results.append(await testCacheSnooping(target: target))

        addLog("âœ… DNS assessment complete - \(results.filter { $0.vulnerabilityConfirmed }.count) vulnerabilities found")

        return results
    }

    // MARK: - Helpers

    private func extractDNSRecords(from output: String) -> [String] {
        var records: [String] = []
        let lines = output.components(separatedBy: "\n")

        var inAnswerSection = false
        for line in lines {
            if line.contains("ANSWER SECTION") {
                inAnswerSection = true
                continue
            }

            if inAnswerSection {
                if line.isEmpty || line.starts(with: ";") {
                    break
                }
                records.append(line.trimmingCharacters(in: .whitespaces))
            }
        }

        return records
    }

    private func runCommand(_ path: String, args: [String]) async -> String? {
        return await withCheckedContinuation { continuation in
            let task = Process()
            task.executableURL = URL(fileURLWithPath: path)
            task.arguments = args

            let outputPipe = Pipe()
            let errorPipe = Pipe()
            task.standardOutput = outputPipe
            task.standardError = errorPipe

            do {
                try task.run()

                DispatchQueue.global().asyncAfter(deadline: .now() + 10) {
                    if task.isRunning {
                        task.terminate()
                    }
                }

                task.waitUntilExit()

                let outputData = outputPipe.fileHandleForReading.readDataToEndOfFile()
                let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()

                let output = String(data: outputData, encoding: .utf8) ?? ""
                let error = String(data: errorData, encoding: .utf8) ?? ""

                let combined = output + error
                continuation.resume(returning: combined.isEmpty ? nil : combined)
            } catch {
                continuation.resume(returning: nil)
            }
        }
    }

    private func addLog(_ message: String) {
        let timestamp = Date().formatted(date: .omitted, time: .standard)
        let logMessage = "[\(timestamp)] \(message)"
        testLog.append(logMessage)
        print(logMessage)
    }
}
