//
//  SSHModule.swift
//  Bastion
//
//  SSH security testing module
//  Tests for weak passwords, default credentials, and SSH vulnerabilities
//  Author: Jordan Koch
//  Date: 2025-01-17
//

import Foundation

@MainActor
class SSHModule: ObservableObject {
    @Published var testLog: [String] = []
    @Published var isRunning = false

    // Common SSH usernames
    private let commonUsernames = [
        "root", "admin", "administrator", "user", "pi", "ubuntu",
        "debian", "centos", "oracle", "postgres", "mysql", "git"
    ]

    // Common passwords
    private let commonPasswords = [
        "password", "admin", "123456", "12345678", "root", "toor",
        "raspberry", "alpine", "changeme", "welcome", "qwerty",
        "letmein", "monkey", "dragon", "master", "default"
    ]

    // Default credentials database
    private let defaultCredentials: [(String, String, String)] = [
        ("root", "root", "Generic Linux"),
        ("root", "toor", "Kali Linux / BackTrack"),
        ("admin", "admin", "Most routers/IoT"),
        ("admin", "password", "Common default"),
        ("pi", "raspberry", "Raspberry Pi"),
        ("ubuntu", "ubuntu", "Ubuntu default"),
        ("user", "user", "Generic user"),
        ("admin", "", "Empty password"),
        ("root", "", "Empty root password"),
        ("administrator", "admin", "Windows-style"),
        ("oracle", "oracle", "Oracle Database"),
        ("postgres", "postgres", "PostgreSQL")
    ]

    // Test SSH with weak/default passwords
    func testDefaultCredentials(target: String, port: Int = 22) async -> AttackResult {
        var result = AttackResult(targetIP: target, attackType: .defaultCredentials, module: "SSH")
        addLog("Testing default SSH credentials on \(target):\(port)")

        for (username, password, description) in defaultCredentials {
            SafetyValidator.shared.logActivity("SSH credential test", target: "\(target) - \(username)")

            if await attemptSSHLogin(target: target, port: port, username: username, password: password) {
                result.status = .success
                result.exploitSuccessful = true
                result.vulnerabilityConfirmed = true
                result.details = "✓ SUCCESS: Default credentials found: \(username):\(password) (\(description))"
                result.evidence.append("Logged in with: \(username):\(password)")
                addLog("⚠️ CRITICAL: SSH login successful with \(username):\(password)")

                return result
            }
        }

        result.status = .failed
        result.details = "No default credentials found"
        addLog("SSH default credential test complete - no matches")

        return result
    }

    // Brute force SSH (limited attempts)
    func bruteForceSSH(target: String, port: Int = 22, username: String) async -> AttackResult {
        var result = AttackResult(targetIP: target, attackType: .sshBruteForce, module: "SSH")
        addLog("Testing common passwords for user '\(username)' on \(target):\(port)")

        let limitedPasswords = Array(commonPasswords.prefix(20)) // Limit to prevent actual DoS

        for password in limitedPasswords {
            try? await SafetyValidator.shared.checkRateLimit()
            SafetyValidator.shared.logActivity("SSH password test", target: "\(target) - \(username)")

            if await attemptSSHLogin(target: target, port: port, username: username, password: password) {
                result.status = .success
                result.exploitSuccessful = true
                result.vulnerabilityConfirmed = true
                result.details = "✓ SUCCESS: Weak password found: \(username):\(password)"
                result.evidence.append("Logged in with: \(username):\(password)")
                addLog("⚠️ CRITICAL: Weak SSH password found: \(username):\(password)")

                return result
            }

            // Small delay to prevent DoS
            try? await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds
        }

        result.status = .failed
        result.details = "No weak passwords found (tested \(limitedPasswords.count) common passwords)"
        addLog("SSH brute force test complete - no matches")

        return result
    }

    // Attempt SSH login
    private func attemptSSHLogin(target: String, port: Int, username: String, password: String) async -> Bool {
        // Try sshpass first (preferred method)
        if await attemptWithSshpass(target: target, port: port, username: username, password: password) {
            return true
        }

        // Fallback to expect script
        return await attemptWithExpect(target: target, port: port, username: username, password: password)
    }

    // Use sshpass for password authentication
    private func attemptWithSshpass(target: String, port: Int, username: String, password: String) async -> Bool {
        return await withCheckedContinuation { continuation in
            let task = Process()

            // Check if sshpass is installed
            if FileManager.default.fileExists(atPath: "/opt/homebrew/bin/sshpass") {
                task.executableURL = URL(fileURLWithPath: "/opt/homebrew/bin/sshpass")
            } else if FileManager.default.fileExists(atPath: "/usr/local/bin/sshpass") {
                task.executableURL = URL(fileURLWithPath: "/usr/local/bin/sshpass")
            } else {
                // sshpass not installed
                continuation.resume(returning: false)
                return
            }

            task.arguments = [
                "-p", password,
                "ssh",
                "-o", "StrictHostKeyChecking=no",
                "-o", "UserKnownHostsFile=/dev/null",
                "-o", "ConnectTimeout=5",
                "-p", "\(port)",
                "\(username)@\(target)",
                "echo SUCCESS"
            ]

            let outputPipe = Pipe()
            let errorPipe = Pipe()
            task.standardOutput = outputPipe
            task.standardError = errorPipe

            do {
                try task.run()

                // Timeout after 8 seconds
                DispatchQueue.global().asyncAfter(deadline: .now() + 8) {
                    if task.isRunning {
                        task.terminate()
                    }
                }

                task.waitUntilExit()

                let outputData = outputPipe.fileHandleForReading.readDataToEndOfFile()
                let output = String(data: outputData, encoding: .utf8) ?? ""

                continuation.resume(returning: output.contains("SUCCESS"))
            } catch {
                continuation.resume(returning: false)
            }
        }
    }

    // Use expect script as fallback
    private func attemptWithExpect(target: String, port: Int, username: String, password: String) async -> Bool {
        return await withCheckedContinuation { continuation in
            // Create expect script
            let expectScript = """
            #!/usr/bin/expect -f
            set timeout 5
            spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p \(port) \(username)@\(target) echo SUCCESS
            expect {
                "password:" {
                    send "\(password)\\r"
                    expect {
                        "SUCCESS" { exit 0 }
                        timeout { exit 1 }
                    }
                }
                timeout { exit 1 }
            }
            """

            let tempScript = FileManager.default.temporaryDirectory.appendingPathComponent("ssh_test_\(UUID().uuidString).exp")

            do {
                try expectScript.write(to: tempScript, atomically: true, encoding: .utf8)

                // Make executable
                let chmod = Process()
                chmod.executableURL = URL(fileURLWithPath: "/bin/chmod")
                chmod.arguments = ["+x", tempScript.path]
                try? chmod.run()
                chmod.waitUntilExit()

                // Run expect script
                let task = Process()
                task.executableURL = tempScript
                task.arguments = []

                let outputPipe = Pipe()
                task.standardOutput = outputPipe
                task.standardError = outputPipe

                try task.run()

                // Timeout
                DispatchQueue.global().asyncAfter(deadline: .now() + 8) {
                    if task.isRunning {
                        task.terminate()
                    }
                }

                task.waitUntilExit()

                // Cleanup
                try? FileManager.default.removeItem(at: tempScript)

                continuation.resume(returning: task.terminationStatus == 0)
            } catch {
                continuation.resume(returning: false)
            }
        }
    }

    // Check for SSH vulnerabilities
    func checkSSHVulnerabilities(target: String, version: String?) async -> [Vulnerability] {
        var vulnerabilities: [Vulnerability] = []
        addLog("Checking SSH vulnerabilities for version: \(version ?? "unknown")")

        guard let version = version else {
            return vulnerabilities
        }

        // Check against CVE database
        let cves = CVEDatabase.shared.findCVEs(service: "OpenSSH", version: version)

        for cve in cves.prefix(10) { // Limit to top 10
            var vuln = Vulnerability(
                title: cve.id,
                description: cve.description,
                severity: cve.severity,
                cveId: cve.id
            )
            vuln.cvssScore = cve.cvssScore
            vuln.exploitAvailable = cve.exploitAvailable
            vuln.affectedService = "SSH"
            vuln.affectedVersion = version

            vulnerabilities.append(vuln)
            addLog("Found CVE: \(cve.id) - CVSS \(cve.cvssScore)")
        }

        return vulnerabilities
    }

    // Enumerate users (CVE-2018-15473)
    func enumerateUsers(target: String, port: Int = 22) async -> [String] {
        addLog("Attempting user enumeration on \(target):\(port)")

        var validUsers: [String] = []

        for username in commonUsernames {
            // Timing attack to detect valid users
            let start = Date()
            _ = await attemptSSHLogin(target: target, port: port, username: username, password: "invalidpassword")
            let duration = Date().timeIntervalSince(start)

            // If response is slower, user might exist (timing side-channel)
            if duration > 2.0 {
                validUsers.append(username)
                addLog("Possible valid user detected: \(username)")
            }
        }

        return validUsers
    }

    private func addLog(_ message: String) {
        let timestamp = Date().formatted(date: .omitted, time: .standard)
        testLog.append("[\(timestamp)] \(message)")
    }
}
